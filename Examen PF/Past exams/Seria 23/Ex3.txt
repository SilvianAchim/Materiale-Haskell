newtype ReaderM env a = ReaderM { runReaderM :: env -> Either String a }

instance Monad (ReaderM env) where
    return x = ReaderM $ \_ -> Right x
    (ReaderM rma) >>= f = ReaderM $ \env ->
        case rma env of
            Left errorMsg -> Left errorMsg
            Right value -> runReaderM (f value) env

testReaderM :: ReaderM String String
testReaderM = ma >>= k
  where
    ma = ReaderM $ \str -> if length str > 10 then Right (length str) else Left "String is too short"
    k val = ReaderM $ \str -> if val `mod` 2 == 0 then Right "Even length" else Left "Odd length"

main :: IO ()
main = do
    print $ runReaderM testReaderM "Hello World"
    print $ runReaderM testReaderM "Hello!"



Pentru a implementa instanța clasei Monad pentru tipul ReaderM, trebuie să definim funcțiile return și >>= (bind) care respectă legile monadei. Tipul ReaderM încapsulează o funcție care acceptă un mediu env și returnează un Either String a, permițând gestionarea erorilor și accesul la un mediu extern în calculul valorii sale.

Definirea Tipului ReaderM
haskell
Copy code
newtype ReaderM env a = ReaderM { runReaderM :: env -> Either String a }
Implementarea Instanței Monad
haskell
Copy code
instance Monad (ReaderM env) where
    return x = ReaderM $ \_ -> Right x
    (ReaderM rma) >>= f = ReaderM $ \env ->
        case rma env of
            Left errorMsg -> Left errorMsg
            Right value -> runReaderM (f value) env
În această implementare:

Funcția return creează un ReaderM care ignoră mediul și întoarce întotdeauna un rezultat de succes (Right x).
Operatorul >>= lansează calculul inițial rma cu un mediu dat env, apoi, în funcție de rezultat:
Dacă rma eșuează (Left), propagă mesajul de eroare fără să apeleze funcția f.
Dacă rma reușește (Right), aplică funcția f la valoarea rezultată pentru a produce un nou ReaderM, apoi execută acest nou ReaderM cu același mediu env.
Testarea cu testReaderM
Să utilizăm expresia dată pentru testare:

haskell
Copy code
testReaderM :: ReaderM String String
testReaderM = ma >>= k
  where
    ma = ReaderM $ \str -> if length str > 10 then Right (length str) else Left "String is too short"
    k val = ReaderM $ \str -> if val `mod` 2 == 0 then Right "Even length" else Left "Odd length"
Pentru a testa acest cod, putem rula testReaderM cu diferite string-uri ca mediu și evaluăm rezultatul:

haskell
Copy code
main :: IO ()
main = do
    print $ runReaderM testReaderM "Hello World"
    print $ runReaderM testReaderM "Hello!"
Primul apel va returna Right "Even length" pentru că lungimea string-ului "Hello World" este mai mare decât 10 și lungimea sa este pară. Al doilea apel va returna Left "String is too short" pentru că lungimea string-ului "Hello!" este mai mică decât 10.

Această implementare a Monad pentru ReaderM ilustrează cum putem compune calculuri care depind de un mediu și care pot eșua, gestionând erorile într-un mod tipic pentru Haskell, prin utilizarea tipului Either.